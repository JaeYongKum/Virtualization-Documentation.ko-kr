---
title: 가상 인터럽트 컨트롤러
description: 하이퍼바이저 가상 인터럽트 컨트롤러 인터페이스
keywords: hyper-v
author: alexgrest
ms.author: alegre
ms.date: 10/15/2020
ms.topic: reference
ms.prod: windows-10-hyperv
ms.openlocfilehash: 4311ac0698bfda86c4a840c2cc7052828f808e59
ms.sourcegitcommit: d43632e3dc22e2b7a256b5c15fbb665c047de286
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/16/2020
ms.locfileid: "92120833"
---
# <a name="virtual-interrupt-controller"></a>가상 인터럽트 컨트롤러

하이퍼바이저는 가상 프로세서에 대 한 인터럽트 전달을 가상화 합니다. 이는 가상화 된 로컬 APIC의 확장인 Syic (가상 인터럽트 컨트롤러)를 사용 하 여 수행 됩니다. 즉, 각 가상 프로세서에는 Syic 확장이 있는 로컬 APIC 인스턴스가 있습니다. 이러한 확장은 다음 장에서 설명 하는 간단한 파티션 간 통신 메커니즘을 제공 합니다.
파티션에 전달 된 인터럽트는 외부 및 내부의 두 범주로 나뉩니다. 외부 인터럽트는 다른 파티션 또는 장치에서 시작 되며 내부 인터럽트는 파티션 자체 내에서 발생 합니다.

외부 인터럽트는 다음과 같은 경우에 생성 됩니다.

- 실제 하드웨어 장치는 하드웨어 인터럽트를 생성 합니다.
- 부모 파티션은 일반적으로 하드웨어 장치를 에뮬레이트하는 프로세스에서 가상 인터럽트를 어설션 합니다.
- 하이퍼바이저는 파티션에 대 한 메시지 (예: 가로채기로 인해)를 전달 합니다.
- 다른 파티션이 메시지를 게시 합니다.
- 다른 파티션은 이벤트를 신호로 보냅니다.

내부 인터럽트는 다음과 같은 경우에 생성 됩니다.

- 가상 프로세서는 APIC 인터럽트 명령 레지스터 (ICR)에 액세스 합니다.
- 가상 타이머가 만료 됩니다.

## <a name="local-apic"></a>로컬 APIC

Syic는 로컬 APIC의 상위 집합입니다. 이 APIC에 대 한 인터페이스는 32 비트 메모리 매핑된 레지스터 집합에 의해 제공 됩니다. 이 로컬 APIC (메모리 매핑된 레지스터의 동작 포함)는 Intel의 및 AMD 설명서에 설명 된 대로 일반적으로 P4/Xeon 시스템의 로컬 APIC와 호환 됩니다.

하이퍼바이저의 로컬 APIC 가상화는 다음과 같은 사소한 방법으로 실제 APIC 작업에서 벗어날 수 있습니다.

- 물리적 시스템에서 IA32_APIC_BASE MSR은 시스템의 각 프로세서 마다 다를 수 있습니다. 하이퍼바이저는 파티션 내의 모든 가상 프로세서에 대해이 MSR에 동일한 값이 포함 되도록 요구할 수 있습니다. 따라서이 MSR은 파티션 전체 값으로 처리 될 수 있습니다. 가상 프로세서가이 레지스터를 수정 하는 경우이 값은 파티션 내의 모든 가상 프로세서에 효과적으로 전파 될 수 있습니다.
- IA32_APIC_BASE MSR은 APIC를 사용 하거나 사용 하지 않도록 설정 하기 위해 "글로벌 사용" 비트를 정의 합니다. 가상화 된 APIC는 항상 사용 하도록 설정할 수 있습니다. 그렇다면이 비트는 항상 1로 설정 됩니다.
- 하이퍼바이저의 로컬 APIC는 가상 SMIs (시스템 관리 인터럽트)를 생성 하지 못할 수 있습니다.
- 파티션 내의 여러 가상 프로세서에 동일한 APIC Id가 할당 되는 경우 대상 인터럽트 배달의 동작이 정의 되지 않은 상태로 boundedly 됩니다. 즉, 하이퍼바이저는 단일 가상 프로세서, 지정 된 APIC ID를 사용 하는 모든 가상 프로세서 또는 가상 프로세서가 없는 가상 프로세서에만 인터럽트를 제공 합니다. 이 상황은 게스트 프로그래밍 오류로 간주 됩니다.
- 일부 메모리 매핑된 APIC 레지스터는 가상 MSRs를 통해 액세스할 수 있습니다.
- 하이퍼바이저에서 게스트의 APIC Id를 수정 하는 것을 허용 하지 않을 수 있습니다.

이 섹션의 나머지 부분에서는 로컬 APIC의 확장인 Syic 기능의 부분만 설명 합니다.

### <a name="local-apic-msr-accesses"></a>로컬 APIC MSR 액세스

하이퍼바이저는 높은 사용량 메모리 매핑된 APIC 레지스터에 가속화 된 MSR 액세스를 제공 합니다. TPR, EOI 및 ICR 레지스터가 여기에 해당 합니다. ICR low 및 ICR high 레지스터는 하나의 MSR로 결합 됩니다. 성능상의 이유로, 게스트 운영 체제는 APIC를 사용 하기 위한 하이퍼바이저 권장 사항을 따라야 합니다.

| MSR 주소      | 이름 등록       | Description                                                                 |
|------------------|---------------------|-----------------------------------------------------------------------------|
| 0x40000070       | HV_X64_MSR_EOI      | APIC EOI 액세스                                                       |
| 0x40000071       | HV_X64_MSR_ICR      | APIC ICR-high 및 ICR에 액세스 합니다.                                      |
| 0x40000072       | HV_X64_MSR_TPR      | APIC TPR 액세스                                                         |

#### <a name="hv_x64_msr_eoi"></a>HV_X64_MSR_EOI

| 비트          | Description                         | 특성                                                  |
|---------------|-------------------------------------|-------------------------------------------------------------|
| 63:32         | RsvdZ (예약 됨, 0 이어야 함)    | 쓰기                                                       |
| 31:0          | EOI 값                           | 쓰기                                                       |

#### <a name="hv_x64_msr_icr"></a>HV_X64_MSR_ICR

| 비트          | Description                         | 특성                                                  |
|---------------|-------------------------------------|-------------------------------------------------------------|
| 63:32         | ICR high 값                      | 읽기/쓰기                                                |
| 31:0          | ICR low 값                       | 읽기/쓰기                                                |

#### <a name="hv_x64_msr_tpr"></a>HV_X64_MSR_TPR

| 비트          | Description                         | 특성                                                  |
|---------------|-------------------------------------|-------------------------------------------------------------|
| 63:8          | RsvdZ (예약 됨, 0 이어야 함)    | 읽기/쓰기                                                |
| 7:0           | TPR 값                           | 읽기/쓰기                                                |

이 MSR은 32 비트 모드 게스트 파티션에서 TPR에 대 한 액세스를 가속화 하기 위한 것입니다. 64 비트 모드 게스트 파티션은 CR8을 통해 TPR를 설정 해야 합니다.

### <a name="synthetic-cluster-ipi"></a>가상 클러스터 IPI

하이퍼바이저는 가상 프로세서의 임의 집합에 가상 고정 인터럽트를 보낼 수 있는 hypercall를 지원 합니다.

| Hypercall                                                                           | Description                                     |
|-------------------------------------------------------------------------------------|-------------------------------------------------|
| [HvCallSendSyntheticClusterIpi](hypercalls/HvCallSendSyntheticClusterIpi.md)      | 지정 된 가상 프로세서 집합에 가상 고정 인터럽트를 보냅니다. |
| [HvCallSendSyntheticClusterIpiEx](hypercalls/HvCallSendSyntheticClusterIpiEx.md)  | HvCallSendSyntheticClusterIpi와 마찬가지로는 스파스 VP를 입력으로 사용 합니다.    |

### <a name="eoi-assist"></a>EOI 지원

[가상 프로세서 지원 페이지](vp-properties.md#virtual-processor-assist-page) 의 한 필드는 EOI 지원 필드입니다. EOI 지원 필드는 오버레이 페이지의 오프셋 0에 있으며 크기는 32 비트입니다. EOI 지원 필드의 형식은 다음과 같습니다.

| 비트          | Description                         | 특성                                                  |
|---------------|-------------------------------------|-------------------------------------------------------------|
| 31:1          | RsvdZ                               | 읽기/쓰기                                                |
| 0             | EOI 필요 없음                     | 읽기/쓰기                                                |

게스트 OS는 가상 VP 지원 페이지의 EOI 지원 필드에 0을 자동으로 기록 하 고 "No EOI required" 필드가 이전에 0 인지 여부를 확인 하 여 EOI를 수행 합니다. 이 경우 OS는 HV_X64_APIC_EOI MSR에 써야 합니다. 따라서 하이퍼바이저에 대 한 인터셉트를 트리거합니다. EOI을 수행 하는 데 권장 되는 코드는 다음과 같습니다.

```
lea rcx, [VirtualApicAssistVa]
btr [rcx], 0
jc NoEoiRequired

mov ecx, HV_X64_APIC_EOI
wrmsr

NoEoiRequired:
```

하이퍼바이저는 다음 조건이 충족 되는 경우 가상 인터럽트를 주입할 때 "No EOI required" 비트를 설정 합니다.

- 가상 인터럽트가에 지 트리거된 경우
- 보류 중인 우선 순위가 낮은 인터럽트가 없습니다.

나중에 더 낮은 우선 순위의 인터럽트가 요청 된 경우 하이퍼바이저는 후속 EOI에서 가로채기를 발생 시키는 "No EOI required"를 지웁니다.

중첩 된 인터럽트의 경우 가장 높은 우선 순위 인터럽트에 대해서만 EOI 인터셉트를 방지할 수 있습니다. OS에서 수행 하는 EOIs 수에 대 한 개수를 유지 하지 않기 때문에이 작업이 필요 합니다. 따라서 첫 번째 EOI를 방지할 수 있으며, 첫 번째 EOI는 "No EOI Required" 비트를 지우는 것 이므로 다음 EOI는 가로채기를 생성 합니다. 그러나 중첩 된 인터럽트는 드물게 발생 하므로 일반적인 경우에는 문제가 되지 않습니다.

장치 및/또는 i/o APIC (물리적 또는 가상)에는에 지 트리거된 인터럽트에 대 한 EOI 알림이 필요 하지 않습니다. 하이퍼바이저는 가상 APIC 상태를 업데이트 하는 경우에만 해당 EOIs를 가로챕니다. 경우에 따라 가상 APIC 상태를 지연 업데이트할 수 있습니다. 이러한 경우에는 EOI 인터셉트가 필요 하지 않다는 것을 나타내는 하이퍼바이저에 의해 "NoEoiRequired" 비트가 설정 됩니다. 이후 순간에서 하이퍼바이저는 "NoEoiRequired" 비트의 현재 값에 따라 로컬 APIC의 상태를 파생할 수 있습니다.

이 계몽 사용 및 사용 안 함은 해당 순간에 중단 활동 및 APIC 상태와 별도로 언제 든 지 수행할 수 있습니다. 계몽를 사용 하는 동안 "EOI 필요 하지 않음" 값에 관계 없이 기존 EOIs를 수행할 수 있지만,이는 계몽의 성능 이점을 인식 하지 못합니다.
